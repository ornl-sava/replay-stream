{
  "author": {
    "name": "Dominic Tarr",
    "email": "dominic.tarr@gmail.com",
    "url": "http://bit.ly/dominictarr"
  },
  "name": "assertions",
  "description": "loads of useful assert functions in one package",
  "version": "2.3.0",
  "homepage": "https://github.com/dominictarr/assertions",
  "repository": {
    "type": "git",
    "url": "git://github.com/dominictarr/assertions.git"
  },
  "main": "./assert.js",
  "scripts": {
    "test": "meta-test test/*.js"
  },
  "engines": {
    "node": ">= 0.2.0"
  },
  "dependencies": {
    "fomatto": "0.5",
    "render": "0.1",
    "traverser": "1"
  },
  "bundleDependencies": [
    "fomatto"
  ],
  "devDependencies": {},
  "readme": "# Assertions\n\n_assertions_ is a powerful assertion toolkit.  \n\nthere are many useful assertion functions,  \nincluding a few _very useful_ higher order assertion functions.  \nalso, every function has a _curry form and these can be joined together to create reusable specs.\n\n##here I'll explain:\n\nassert that `bar` equals `foo`\n\n``` js\nvar a = require('assertions')\n\na.equal(bar, foo)\n```\ncreate an assertion that anything equals `foo`\n\n``` js\nvar equalFoo = a._equal(foo)\n\n//apply it to some things...\nequalFoo (bar)\nequalFoo (baz)\nequalFoo (zuk)\n```\n\nevery function has a curry form with a leading \"_\",  \nit skips the first arg,  \nand returns an assertion function that you can pass the first arg to later!\n\nokay, so why? \n\nthis starts to get super awesome when you have, example, the `has` assertion:\n\n``` js\n//assert that bar has a property letters: 3, and a name, which is a string.\na.has(bar, {\n  letters: 3,\n, name: function (actual) { a.isString(actual, 'make it a string!') }\n})\n```\n\n`has` is kinda like `deepEqual` but only checks that the property matches if it's a primitive.  \nif the property is a function then `has` assumes that it is an assertion function,  \nand applys the function to the corisponding property on the `actual` object.  \n\nlets rewrite the above example using the curry form:\n\n``` js\n//assert that bar has a property letters: 3, and a name, which is a string.\nvar validTLA = a._has({\n  letters: 3,\n  name: a._isString('make it a string!')\n}, 'must be a real Three Letter Acronym')\n```\nnow we can check that every thing is a valid TLA, oh yeah, lets use the higher order assertion `every`\n\n``` js\na.every([\n  {name: 'WTF', letters: 3},\n  {name: 'OMG', letters: 3},\n  {name: 'BBQ', letters: 3},\n  {name: 'TLA', letters: 3},\n  {name: 'DSL', letters: 3}\n], validTLA)\n```\n\nwe can now use `validTLA` where ever we need to check that something is a TLA, not just in our tests.\n\n## Error Messages\none of the best things about assertions is that it creates very detailed error messages.\n\n``` js\na.every([\n  {name: 'WTF', letters: 3},\n  {name: 'TLA', letters: 3},\n  {name: 'IMHO', letters: 4}\n  ], validTLA)\n```\n\nwill give you a message like this, showing each step of where it went wrong!\n\n``` js\nequal: 4 == 3\nhas: ({ name: \"IMHO\", letters: 4 }).letters must match { letters: 3, name: isString }).letters\nevery: every[2] (== { name: \"IMHO\", letters: 4 }) must pass has, \n  (2 out of 3 have passed)\n    at Object.equal (/home/dominic/source/dev/assertions/elementary.js:11:18)\n    at Object.leaf (/home/dominic/source/dev/assertions/higher.js:175:16)\n    ...\n```\n\n## assertion(actual [, expected...], message)\n\nthat is the raw form of all assertions. this convention is borrowed from the nodejs `assert` module.\n\nsome times `expected` is not necessary, or is optional, \nor may take multiple args. see assertion docs.\n\nif the assertion takes optional args, the last arg is always `message` if it is a string.",
  "readmeFilename": "readme.markdown",
  "_id": "assertions@2.3.0",
  "_from": "assertions@~2.3.0"
}
